**스택**이란 말 그대로 "==쌓아 놓은 더미=="를 뜻한다

### 스택의 특징

- **LIFO**(last in first out)방식으로 동작한다는 것이다
  -> LIFO: 가장 나중에 들어온 데이터가 가장 먼저 나간다
- 삽입과 삭제를 리스트의 한 방향에서 행한다

### 스택의 시간 복잡도

##### 먼저 시간 복잡도는 무엇일까?

시간 복잡도란 ==입력값과 연산의 수행 시간의 상관관계를 나타내는 척도== 를 말한다

시간 복잡도를 표기하는 방법은 3가지가 있다

- Big-O(빅 오) - 최악의 경우
- Big-Ω(빅 오메가) - 최상의 겨우
- Big-θ(빅 세타) - 평균의 경우

이 중에서 Big-O(이하 빅오) 표기법이 가장 많이 사용된다
빅오 표기법은 최악의 경우를 고려하므로 프로그램이 실행되는 과정에서 소요되는 최악의 시간까지 고려할 수 있다

**빅오 표기법의 종류**

**O(1)**
![[Pasted image 20240630211335.png]]
==입력값이 증가하더라도 시간은 증가하지 않는다==
다시 말해 입력값의 크기와 상관 없이 즉시 출력값을 얻어낼 수 있다는 의미이다

O(1)의 시간 복잡도를 가진 알고리즘의 예시로 아래 코드를 들 수 있다

```
function O_1(arr, idx){
	return arr[idx];
}

const arr = [1, 2, 3, 4, 5];
const idx = 1;

console.log(O_1(arr, idx)) // 2
```

---

**O(n)**
![[Pasted image 20240630211632.png]]
==입력값이 증가함에 따라 시간도 증가한다==

아래의 코드를 O(n) 시간 복잡도를 가진 알고리즘의 예로 들 수 있

```
//1
function O_n(n){
	let sum=0;
	for(let i=1; i<=n; i++){
		sum+=i;
	}
	return sum;
}

console.log(O_n(5)) // 15

//2
function O_n2(n){
	let sum=0;
	for(let i=1; i<=(2*n); i++){
		sum+=i;
	}
	return sum;
}
```

만약 위 코드 중 O_n2라는 함수의 시간 복잡도를 나타낸다면 어떻게 나타낼 수 있을까?

###### 정답

O(2n)이라고 생각할 수 있지만 이 또한 O(n)으로 표기한다
이유는 입력값이 커질 수록 계수(n 앞에 있는 수)의미가 점점 퇴색되기 때문이다
만약 같은 비율로 증가하고 있다면 2배가 아닌 3배, 5배로 증가하여도 O(n)이라고 표기한다

---

**O(log n)**
![[Pasted image 20240630212529.png]]
==단순 순환(O(n))이 아닌 경우의 수를 1/2씩 줄여나가며 탐색할 때 사용하는 표기법==
빅오 표기법 중 O(1)다음으로 빠른 시간 복잡도이다

O(log n)의 시간 복잡도를 가지는 알고리즘으로는 이진탐색 있다
-> 원하는 값을 탐색할 때 노드를 이동할 때마다 경우의 수가 절반으로 줄어들기 때문에 O(log n)이다

---

**O(n2)**
![[Pasted image 20240630213112.png]]
==입력값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가==

O(n2)의 시간 복잡도를 가지는 알고리즘은 아래의 코드를 예시로 들 수 있다

```
function O_n2(n){
	for(let i=0; i<n; i++){
		for(let j=0; j<n; j++){
		}
	}
}
```

이외에 n2, n3, n4 모두 O(n2)라고 표기한다

---

**O(2n)**
![[Pasted image 20240630213532.png]]
빅오 표기법 중에서 가장 느린 시간 복잡도를 가진다

O(2n)의 가장 대표적인 알고리즘으로는 피보나치수열이 있다

---

스택의 시간 복잡도는 총 2가지가 있다

스택에 데이터를 삽입, 삭제 할 때는 항상 뒤에서 추가, 삭제를 하면 되기 때문에 O(1)이다

하지만 특정 데이터를 찾을 때는 위에서 부터 순차적으로 찾아야하기 때문에 O(n)이다

### 스택 구현

```
class Stack {

  constructor() {

    this.arr = [];

    this.idx = 0;

  }

  push(item) {

    this.arr[this.idx++] = item;

  }

  pop() {

    if (this.idx <= 0) {

      return "stack에 아무것도 없어용";

    }

    const result = this.arr[--this.idx];

    return result;

  }

  top() {

    return this.arr[this.idx - 1];

  }

  isEmpty() {

    if (this.idx != 0) {

      console.log("스택은 현재 비어있지 않습니다");

      return false;

    }

    console.log("스택은 현재 비어있습니다");

    return true;

  }

  isFull() {

    if (this.idx == 0) {

      console.log("스택은 현재 비어있습니다");

      return false;

    }

    console.log("스택은 현재 비어있지 않습니다");

    return true;

  }

}
```
